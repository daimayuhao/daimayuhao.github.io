---
layout:     post
title:      synchronized关键字（1）
subtitle:   
date:       2017-05-13
author:     lessyh
header-img: img/post-bg-github-cup.jpg
catalog: true
tags: 多线程

---
## 内容思维导图
![](https://user-gold-cdn.xitu.io/2018/8/4/16504e245ceb3ea9?w=1028&h=490&f=jpeg&s=203811)

## 1 简介
&nbsp;&nbsp; &nbsp;&nbsp;**synchronized关键字**，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用**synchronized**方法的线程B（或者C、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：**synchronized** 方法和 **synchronized** 块。

## 2 变量安全性

&nbsp;&nbsp; &nbsp;&nbsp;当多个线程同时共享，**同一个全局变量或静态变量**，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。但是做读操作是不会发生数据冲突问题。

## 3 多个对象多个锁
&nbsp;&nbsp; &nbsp;&nbsp;Demo
&nbsp;&nbsp; &nbsp;&nbsp;HasSelfPrivateNum类：
```
public class HasSelfPrivateNum {
    private int num=0;
   synchronized  public void addI(String username){
        try{
            if(username.equals("a")){
                num=100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            }else{
                num=200;
                System.out.println("b set over!");
            }
            System.out.println(username+" num="+num);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```
&nbsp;&nbsp; &nbsp;&nbsp;线程类ThreadA和ThreadB:
```
public class ThreadA extends Thread {

    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }

}
```
```
public class ThreadB extends Thread {

    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }

}
```
&nbsp;&nbsp; &nbsp;&nbsp;Run类，执行Main方法：
```
public class Run {
    public static void main(String[] args){
        HasSelfPrivateNum numRef1=new HasSelfPrivateNum();
        HasSelfPrivateNum numRef2=new HasSelfPrivateNum();
        ThreadA athread=new ThreadA(numRef1);
        athread.start();
        ThreadB bthread=new ThreadB(numRef2);
        bthread.start();
    }
}
```
&nbsp;&nbsp; &nbsp;&nbsp;运行结果:
```
a set over!
b set over!
b num=200
a num=100
```
&nbsp;&nbsp; &nbsp;&nbsp;例子是两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果是以异步的方式运行的。原因是：示例创建了2个业务对象，在系统中产生了2个锁，所以运行结果是异步的，打印的效果是先打印了b，然后打印了a。

&nbsp;&nbsp; &nbsp;&nbsp;HasSelfPrivateNum.java中使用了synchronized关键字，但打印的顺序却不是同步的是交叉的，为什么？

解： 
&nbsp;&nbsp; &nbsp;&nbsp;关键字 synchronized取得的锁是对象锁，而不是把一段代码或方法（函数）当做锁，如果多个线程访问的是多个对象，则JVM会创建多个锁，互不影响。

番外： 
&nbsp;&nbsp; &nbsp;&nbsp;如果在静态方法上加synchronized关键字，表示锁定类级别的锁，独占class类，这时候多个线程访问的是相同的锁。



 

